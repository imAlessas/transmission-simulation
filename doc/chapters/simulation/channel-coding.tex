\vspace{40px} \section{Channel coding and decoding}
The Hamming encoding and decoding is the most crucial part of the transmission because it is the one responsible for the error correction of the transmission. There are two types of hamming encoding, group coding and cyclic coding: in this case, cyclic coding has been utilized to perform the error correction. It is important to note that the channel coding adds some bits to the codeword: precisely during the encoding phase to the codeword are added 5 symbols, making the sequence length a perfect divisor of $26 + 5 = 31$, meanwhile after the decoding the five symbols at the end of the codeword are removed making it again a perfect divisor of 26.   




\subsection{Cyclic Hamming encoding}
To perform the Hamming encoding to the sequence it is necessary to generate the \texttt{encoding\_matrix} using the \texttt{cyclgen} function\footnote{Note that the function needs to be imported: \texttt{import communications.*}.} that uses the codeword length and the generation polynomial defined at the \hyperref[initial-parameters]{beginning of the code}. The \texttt{hamming\_encoding} function, uses the generated encoding matrix to perform a matrix multiplication and encode the codeword.

\begin{lstlisting}
function encoded_data_matrix = hamming_encoding(binary_data_matrix, codeword_length, k, generation_polynomial)
    % Calculate the number of redundant symbols (parity symbols)
    r = codeword_length - k;
    
    % Generate the cyclic encoding matrix based on the generator polynomial
    [~, cyclic_encoding_matrix] = cyclgen(codeword_length, generation_polynomial);
    
    % Reorder the encoding matrix to match Hamming code requirements
    reorder = [r + 1 : codeword_length, 1 : r];
    cyclic_encoding_matrix = cyclic_encoding_matrix(:, reorder);
    
    % Calculate control symbol values using matrix multiplication
    % Use rem() function to find modulo 2 sum as a remainder of division by 2
    encoded_data_matrix = rem(binary_data_matrix * cyclic_encoding_matrix, 2);
end
\end{lstlisting}


\subsection{Cyclic Hamming decoding}
\todo{Finish here maybe arrange the function with other helper functions to help readibility}


\begin{lstlisting}
    function decoded_data_matrix = hamming_decoding(encoded_data_matrix, codeword_length, k, generation_polynomial)
        % Determine the number of control symbols
        r = codeword_length - k;
        
        % Specify syndrome calculation matrix
        [~, cyclic_encoding_matrix] = cyclgen(codeword_length, generation_polynomial);
        syndrome_matrix = cyclic_encoding_matrix(:, (1:r));
        syndrome_matrix = [syndrome_matrix; eye(r)];
        
        % Calculate syndrome for each codeword
        syndrome_value = rem(encoded_data_matrix * syndrome_matrix, 2);
        syndrome_value = syndrome_value * 2.^(r - 1 : -1 : 0)';
        
    
        % Define associations between syndrome values and error positions
        positions = (1 : codeword_length)'; 
    
        % Initialize vector to store decimal values of binary syndrome patterns
        syndrome_decimal_value_vector = [];
    
        % Convert binary syndrome values to decimal for association
        for i = 1 : codeword_length
            syndrome_decimal_value_vector = [syndrome_decimal_value_vector; bin2dec(num2str(syndrome_matrix(i, :)))];
        end
    
        % Combine positions and corresponding decimal values for sorting
        associations = [positions, syndrome_decimal_value_vector];
    
        % Sort associations based on decimal values for efficient error detection
        associations = sortrows(associations, 2);
    
        % Create correction index for mapping syndrome values to error positions
        correction_index = [0, associations(:, 1)'];
    
        % Map syndrome values to error positions using correction index
        error_indexes = correction_index(syndrome_value + 1);
        
    
        % Define error vector table
        error_vector = [zeros(1, codeword_length);
                        eye(codeword_length)];
        
        % Perform correction by adding the error vector to the received codeword
        codeword = rem(encoded_data_matrix + error_vector(error_indexes + 1, :), 2);
        
        % Read the columns of data symbols to form decoded data
        decoded_data_matrix = codeword(:, 1:k);
    end
\end{lstlisting}
